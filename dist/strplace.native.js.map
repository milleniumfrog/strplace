{"version":3,"file":"strplace.native.js","sources":["../src/strplace.ts"],"sourcesContent":["export function replaceSingle( key: string, string: string, replaceContent: any, flags?: string, passArguments?: any): string {\n\t// set default flags\n\tflags = flags || 'g';\n\t// create Regex\n\tlet regex = new RegExp( key, flags );\n\tlet res: RegExpExecArray | null;\n\tlet counter: number = 0;\n\twhile( (res = regex.exec( string.slice( counter ) )) !== null ) {\n\t\tkey = key.replace( (new RegExp( '\\\\\\\\', 'g')), '' )\n\t\tstring = string.replace( key, typeof replaceContent === 'function' ? replaceContent( '', passArguments ) : replaceContent );\n\t\t++counter;\n\t}\n\treturn string;\n};\n\nexport interface ComplexKey {\n\tkeys: Array<string>;\n\treplacer: ( ( str?: string, passArguments?: any ) => string );\n\tflags: string;\n\t/** for more perfomance with single key placeholders */\n\tcalled?: boolean;\n}\n\n\nexport function replaceComplex ( complexKeys: Array<ComplexKey>, string: string, passArguments?: any) : string {\n\tfor ( let complex of complexKeys )\n\t{\n\t\t// single key placeholders\n\t\tif ( complex.keys[1] === undefined )\n\t\t{\n\t\t\tstring = complex.called !== true ? replaceSingle( complex.keys[0], string, (args?: string, toPass?: any) => { return complex.replacer('', toPass) }, complex.flags, passArguments ) : string;\n\t\t}\n\t\t// 2 key placeholders\n\t\telse\n\t\t{\n\t\t\tlet maxIndex = -1;\n\t\t\tfor ( let inComplex of complexKeys ) \n\t\t\t{\n\t\t\t\t// create Regular expression\n\t\t\t\tlet regex: RegExp = new RegExp( inComplex.keys[0], inComplex.flags );\n\t\t\t\tlet res: RegExpExecArray | null = regex.exec( string );\n\t\t\t\tif ( res !== null ) {\n\t\t\t\t\tmaxIndex = maxIndex < res.index ? res.index : maxIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( maxIndex > 0 )\n\t\t\t{\n\t\t\t\tstring = string.slice(0, maxIndex) + replaceComplex( complexKeys, string.slice( maxIndex ) );\n\t\t\t}\n\t\t\t// search index where pattern is first time\n\t\t\tlet regex: RegExp = new RegExp( complex.keys[0], complex.flags );\n\t\t\tlet res1: RegExpExecArray | null = regex.exec( string );\n\t\t\tif ( res1 !== null )\n\t\t\t{\n\t\t\t\t// find closing pattern in string\n\t\t\t\tregex = new RegExp( complex.keys[1], complex.flags );\n\t\t\t\tlet res2 = regex.exec( string );\n\t\t\t\tlet removeEscapesFromKeys: string[] = [ complex.keys[0].replace( (new RegExp( '\\\\\\\\', 'g')), '' ), complex.keys[1].replace( (new RegExp( '\\\\\\\\', 'g')), '' )]\n\t\t\t\tif ( res2 !== null )\n\t\t\t\t{\n\t\t\t\t\t// create new string\n\t\t\t\t\tstring = string.slice( 0, res1.index ) + complex.replacer( string.slice( res1.index + removeEscapesFromKeys[0].length , res2.index ), passArguments ) + string.slice( res2.index + removeEscapesFromKeys[1].length);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn string;\n}"],"names":["replaceSingle","key","counter","string","complex"],"mappings":"AAAM,SAAUA,oDASqC,6BACnDC,qFAEDC,wBA8BiDC,kGAQ/CC,kBAAgE"}